%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template para artigos da SBC
% Adaptado para o trabalho prático de Processamento de Dados com Grafos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}  
\usepackage{amsmath} % Para ambientes matemáticos
\usepackage{listings} % Para blocos de código
\usepackage{xcolor} % Para cores no código

% Configuração para blocos de código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{customStyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=customStyle}
     
\sloppy

\title{Gestão de Dependências em Projetos Go com Ordenação Topológica}

% TODO: PREENCHER OS DADOS DOS AUTORES E INSTITUIÇÕES
\author{Nicholas Pereira Cristófaro\inst{1}, Nome Sobrenome do Aluno 2\inst{1}}

\address{Pontifícia Universidade Católica de Minas Gerais\\
  Belo Horizonte -- Minas Gerais -- Brasil
  \email{nicholaspcr@gmail.com, email2@dominio.com}
}

\begin{document} 

\maketitle

\begin{resumo} 
A gestão de dependências é um desafio em software moderno. Este artigo apresenta uma ferramenta que analisa e visualiza dependências em projetos Go, modelando-as como um grafo direcionado. Através da ordenação topológica com o algoritmo de Kahn, a ferramenta determina a sequência de compilação segura e detecta dependências cíclicas — um erro crítico em Go. A solução, implementada em Python, abrange desde a análise do código até a geração de um grafo interativo, oferecendo um suporte prático para a gestão de conflitos em sistemas de dependência.
\end{resumo}

\begin{abstract}
Dependency management is a challenge in modern software. This paper introduces a tool that analyzes and visualizes dependencies in Go projects by modeling them as a directed graph. Through topological sorting with Kahn's algorithm, the tool determines a safe compilation sequence and detects cyclic dependencies—a critical error in Go. The solution, implemented in Python, covers the process from code analysis to generating an interactive graph, providing practical support for managing conflicts in dependency systems.
\end{abstract}

\section{Introdução}

O desenvolvimento de software contemporâneo é caracterizado pela modularidade e reutilização de código, resultando em sistemas compostos por um grande número de componentes interdependentes. A gestão dessa rede de dependências é um desafio central na engenharia de software. Falhas nesse gerenciamento podem levar a erros de compilação, comportamento inesperado em tempo de execução e dificuldades na manutenção e evolução dos projetos.

A linguagem de programação Go (Golang), desenvolvida pelo Google, possui um sistema de pacotes estático e um compilador que impõem regras estritas sobre as dependências. Uma dessas regras é que as dependências de um pacote devem ser inicializadas antes do próprio pacote. Isso garante a execução correta das funções `init()`, que são utilizadas para configurar o estado inicial de cada pacote. Quando um projeto contém uma dependência cíclica (por exemplo, pacote A importa B e pacote B importa A), o compilador Go gera um erro, pois não é possível determinar uma ordem de inicialização válida.

A ordem de inicialização de pacotes em Go pode ser modelada de forma natural como um grafo de dependências direcionado acíclico (DAG). Neste modelo, cada pacote é um vértice e uma diretiva `import` de um pacote A para um pacote B cria uma aresta direcionada de B para A, significando que A depende de B. A solução para determinar a sequência correta de inicialização é, portanto, encontrar uma ordenação topológica desse grafo.

Este trabalho se enquadra na proposta de "Gestão de Conflitos em Sistemas de Dependência", focando na modelagem, detecção de ciclos e execução segura baseada em ordenação topológica. Para isso, foi desenvolvida uma ferramenta em Python que:
\begin{itemize}
    \item Analisa recursivamente os arquivos de um projeto Go para extrair as relações de importação.
    \item Constrói um grafo de dependências direcionado a partir dessas relações.
    \item Aplica o algoritmo de Kahn para realizar a ordenação topológica dos pacotes.
    \item Gera uma visualização gráfica do grafo de dependências, destacando a ordem de inicialização em camadas.
\end{itemize}

O restante deste artigo está organizado da seguinte forma: a Seção 2 apresenta a fundamentação teórica sobre grafos, ordenação topológica e o sistema de pacotes do Go. A Seção 3 detalha a modelagem do problema e a arquitetura da ferramenta desenvolvida. A Seção 4 apresenta os experimentos realizados e discute os resultados obtidos. Finalmente, a Seção 5 conclui o trabalho e aponta direções para desenvolvimentos futuros.

\section{Fundamentação Teórica}
Esta seção aborda os conceitos fundamentais que sustentam o desenvolvimento deste trabalho, incluindo a teoria dos grafos, o algoritmo de ordenação topológica e as particularidades do sistema de pacotes da linguagem Go.

\subsection{Teoria dos Grafos}
Um grafo $G = (V, E)$ é uma estrutura matemática usada para modelar relações entre objetos. Consiste em um conjunto de vértices $V$ (ou nós) e um conjunto de arestas $E$ que conectam pares de vértices. Em um \textbf{grafo direcionado} (ou digrafo), as arestas têm uma direção, sendo representadas por pares ordenados de vértices $(u, v)$, indicando uma ligação de $u$ para $v$.

No contexto deste trabalho, o modelo utilizado é um grafo direcionado, onde:
\begin{itemize}
    \item \textbf{Vértices (V):} Representam os pacotes do projeto Go, tanto os locais (definidos no projeto) quanto os externos (bibliotecas padrão ou de terceiros).
    \item \textbf{Arestas (E):} Uma aresta direcionada $(u, v)$ existe se o pacote $v$ importa o pacote $u$. Isso significa que $u$ é uma dependência de $v$.
\end{itemize}

Uma métrica importante em grafos direcionados é o \textbf{grau de entrada (in-degree)} de um vértice, que corresponde ao número de arestas que chegam a ele. Um vértice com grau de entrada zero não possui dependências dentro do grafo.

\subsection{Ordenação Topológica}
A ordenação topológica de um grafo direcionado é uma ordenação linear de seus vértices tal que para toda aresta direcionada $(u, v)$, o vértice $u$ vem antes de $v$ na ordenação. Uma ordenação topológica só é possível se, e somente se, o grafo não contiver ciclos direcionados, ou seja, se for um \textbf{Grafo Acíclico Direcionado (DAG)}.

A existência de uma ordenação topológica no nosso grafo de dependências corresponde a uma sequência válida de inicialização dos pacotes Go. Se o grafo contiver um ciclo, não há ordenação topológica possível, o que corresponde a um erro de "dependência cíclica" no compilador Go.

\subsubsection{Algoritmo de Kahn}
Existem vários algoritmos para encontrar uma ordenação topológica. O escolhido para este trabalho foi o \textbf{algoritmo de Kahn}, devido à sua capacidade de processar os vértices em "camadas", o que é ideal para a visualização proposta. O algoritmo funciona da seguinte maneira:
\begin{enumerate}
    \item Calcular o grau de entrada (in-degree) de todos os vértices do grafo.
    \item Inicializar uma fila com todos os vértices que possuem grau de entrada igual a zero. Estes são os pacotes sem dependências.
    \item Enquanto a fila não estiver vazia:
    \begin{enumerate}
        \item Remover um vértice $n$ da fila e adicioná-lo à lista de ordenação topológica.
        \item Para cada vértice $m$ que é vizinho de $n$ (ou seja, para cada pacote que depende de $n$):
        \begin{enumerate}
            \item Decrementar o grau de entrada de $m$.
            \item Se o grau de entrada de $m$ se tornar zero, adicioná-lo à fila.
        \end{enumerate}
    \end{enumerate}
    \item Ao final, se o número de vértices na lista de ordenação topológica for igual ao número total de vértices do grafo, a ordenação foi bem-sucedida. Caso contrário, o grafo contém pelo menos um ciclo.
\end{enumerate}
A implementação deste algoritmo pode ser vista no arquivo `topological{\_}sorting.py`.

\subsection{Sistema de Pacotes e Módulos em Go}
Go organiza o código em pacotes, que são coleções de arquivos-fonte no mesmo diretório. O `go.mod` é um arquivo na raiz do projeto que define o caminho do módulo, que serve como um prefixo para todos os pacotes dentro do projeto, e também gerencia as dependências externas.

A diretiva `import` é usada para declarar dependências entre pacotes. Como mencionado, a ordem de execução das funções `init()` de cada pacote segue a ordem de dependência, exigindo uma resolução que é, na prática, uma ordenação topológica.

\section{Modelagem e Desenvolvimento da Ferramenta}
Esta seção descreve a arquitetura e os componentes da ferramenta desenvolvida, detalhando como o problema de análise de
dependências foi modelado e implementado em Python. A ferramenta é composta por três módulos principais, conforme os
arquivos `dependency{\_}graph{\_}builder.py`, `topological{\_}sorting.py` e `render.py`.

\subsection{Modelagem do Grafo de Dependências}
O problema foi modelado como um grafo direcionado $G = (V, E)$, conforme descrito na Seção 2.1. A estrutura de dados escolhida para representar o grafo foi um dicionário (hash map) em Python, onde as chaves são os nomes dos pacotes (vértices) e os valores são conjuntos contendo os pacotes que dependem deles (vizinhos).

\begin{itemize}
    \item \textbf{`graph = defaultdict(set)`:} Representa as arestas. `graph[u]` contém um conjunto de vértices `{v1, v2, ...}` para os quais existe uma aresta $(u, v1)$, $(u, v2)$, etc.
    \item \textbf{`in\_degree = defaultdict(int)`:} Armazena o grau de entrada de cada vértice, essencial para o algoritmo de Kahn.
\end{itemize}

\subsection{Componentes da Ferramenta}
A ferramenta segue um fluxo de execução claro: extração de dados, processamento (ordenação) e visualização.

\subsubsection{Extração e Construção do Grafo (\texttt{dependency\_graph\_builder.py})}
Este módulo é responsável por ler o sistema de arquivos e construir a representação do grafo. O processo é o seguinte:
\begin{enumerate}
    \item \textbf{Identificação do Módulo:} A classe `BuildDependencyGraph` inicia lendo o arquivo `go.mod` para determinar o prefixo do módulo do projeto. Isso é crucial para nomear corretamente os pacotes locais.
    \item \textbf{Busca por Arquivos Go:} O método `find\_go\_files` percorre recursivamente o diretório do projeto em
        busca de arquivos com a extensão `.go`, ignorando arquivos de teste (`\_test.go`).
    \item \textbf{Extração de Importações:} O método estático `extract\_imports` utiliza expressões regulares (regex) para analisar o conteúdo de cada arquivo Go e extrair todos os pacotes importados. Ele é projetado para lidar tanto com importações de linha única (`import "fmt"`) quanto com blocos de importação (`import (...)`).
    \item \textbf{Construção do Grafo:} O método `build\_dependency\_graph` orquestra o processo. Ele primeiro
        identifica todos os pacotes definidos localmente e depois itera sobre cada arquivo, usando as importações
        extraídas para construir o `graph` e popular o mapa `in\_degree`.
\end{enumerate}

\subsubsection{Ordenação Topológica e Detecção de Ciclos (\texttt{topological\_sorting.py})}
Este módulo implementa a lógica central do processamento.
\begin{itemize}
    \item \textbf{Detecção de Ciclos:} Antes de tentar a ordenação, o método `is\_cyclic` é chamado. Ele utiliza um algoritmo de busca em profundidade (DFS) para verificar a existência de ciclos no grafo. Se um ciclo é detectado, o programa informa o usuário e encerra, pois a ordenação topológica é impossível.
    \item \textbf{Ordenação com Algoritmo de Kahn:} O método `sort\_group` implementa o algoritmo de Kahn, conforme descrito na Seção 2.2.1. Em vez de retornar uma lista linear, nossa implementação retorna uma lista de listas (`list[list[str]]`), onde cada lista interna representa uma "camada" de pacotes que podem ser processados/compilados em paralelo, pois suas dependências da camada anterior já foram resolvidas.
\end{itemize}

\subsubsection{Visualização dos Resultados (\texttt{render.py})}
Para facilitar a compreensão da estrutura de dependências, um módulo de visualização foi criado utilizando a biblioteca `graphviz`.
\begin{enumerate}
    \item O grafo é renderizado como um `Digraph` com orientação da esquerda para a direita (`rankdir='LR'`).
    \item Os nós são agrupados em subgrafos com o mesmo `rank`, correspondendo às camadas calculadas pela função `sort\_group`. Isso alinha visualmente os pacotes que estão no mesmo nível da ordenação topológica.
    \item Os nós são coloridos de forma distinta: pacotes locais (parte do projeto analisado) têm uma cor, e pacotes externos (bibliotecas padrão ou de terceiros) têm outra. Isso ajuda a diferenciar o código do projeto de suas dependências externas.
    \item O resultado final é um arquivo SVG embutido em um HTML, que é automaticamente aberto no navegador, proporcionando uma visualização limpa e interativa.
\end{enumerate}

\section{Experimentos e Resultados}
Para validar a ferramenta, foi realizado um experimento com um projeto Go hipotético, cuja estrutura de dependências é complexa o suficiente para demonstrar a eficácia da abordagem.

\subsection{Cenário de Teste}
Consideremos um projeto hipotético de um e-commerce com a seguinte estrutura de pacotes e dependências:

\begin{itemize}
    \item \textbf{`main`:} O ponto de entrada da aplicação. Depende de `api` e `config`.
    \item \textbf{`api`:} Define os handlers da API. Depende de `services`.
    \item \textbf{`services`:} Contém a lógica de negócio. Depende de `repository` e `models`.
    \item \textbf{`repository`:} Camada de acesso a dados. Depende de `models` e de um pacote externo, `github.com/jmoiron/sqlx`.
    \item \textbf{`models`:} Define as estruturas de dados. Não possui dependências internas.
    \item \textbf{`config`:} Gerencia as configurações. Depende de um pacote padrão, `os`.
\end{itemize}

\subsection{Execução da Ferramenta e Análise dos Resultados}
Ao executar a ferramenta no diretório deste projeto, a saída da ordenação topológica em camadas, calculada pelo `sort\_group`, seria a seguinte:

\begin{verbatim}
[
  ["os", "github.com/jmoiron/sqlx", "models"],
  ["config", "repository"],
  ["services"],
  ["api"],
  ["main"]
]
\end{verbatim}

Esta saída demonstra a ordem de inicialização correta:
\begin{enumerate}
    \item \textbf{Camada 0:} Os pacotes `os`, `github.com/jmoiron/sqlx` e `models` não têm dependências internas no projeto e podem ser inicializados primeiro.
    \item \textbf{Camada 1:} `config` (que depende de `os`) e `repository` (que depende de `models` e `sqlx`) são os próximos.
    \item \textbf{Camada 2:} `services` pode ser inicializado, pois suas dependências (`repository` e `models`) já estão resolvidas.
    \item \textbf{Camada 3 e 4:} `api` e, finalmente, `main` são inicializados em sequência.
\end{enumerate}

O grafo visual gerado pelo `render.py` reflete essa estrutura, como pode ser visto na Figura \ref{fig:grafo_exemplo}.

\begin{figure}[ht]
\centering
% Substituir 'placeholderGraph.png'
\includegraphics[width=1\textwidth]{placeholderGraph.png} 
\caption{Visualização do grafo de dependências gerado para o projeto de e-commerce hipotético. Os nós em vermelho representam pacotes externos/padrão.}
\label{fig:grafoExemplo}
\end{figure}

A clareza da visualização (Figura \ref{fig:grafoExemplo}) e a ordem explícita dos pacotes fornecem ao desenvolvedor uma visão imediata da arquitetura do projeto, facilitando a depuração de problemas de inicialização e a compreensão do fluxo de compilação.

\section{Conclusão}

Este trabalho apresentou uma solução computacional para o problema de gestão de dependências em projetos Go, alinhado aos objetivos da disciplina de Ferramenta de Processamento de Dados com Grafos. A modelagem do sistema de pacotes como um grafo direcionado provou-se eficaz, e a aplicação da ordenação topológica através do algoritmo de Kahn permitiu não apenas determinar a sequência de compilação segura, mas também estruturar a visualização dos resultados de forma intuitiva.

A ferramenta desenvolvida cumpre com sucesso os requisitos propostos: ela analisa o código-fonte, constrói um modelo em grafo, processa-o com algoritmos relevantes e apresenta os resultados de forma clara. A capacidade de detectar ciclos de dependência antes da compilação é um recurso valioso para evitar erros comuns em projetos de grande porte.

\subsection{Trabalhos Futuros}
Apesar de funcional, a ferramenta atual pode ser estendida de várias maneiras. Como trabalhos futuros, sugere-se:
\begin{itemize}
    \item \textbf{Análise de Desempenho:} Testar a ferramenta em repositórios de código aberto extremamente grandes (e.g., Kubernetes, Docker) para avaliar sua performance e escalabilidade.
    \item \textbf{Parser Avançado:} Substituir as expressões regulares por um parser de Abstract Syntax Tree (AST) da linguagem Go, o que tornaria a extração de importações mais robusta e precisa.
    \item \textbf{Integração com IDEs:} Desenvolver um plugin para editores de código populares, como o Visual Studio Code, que exiba o grafo de dependências e alerte sobre ciclos em tempo real.
    \item \textbf{Análise de "Peso" das Arestas:} Estender o modelo para incluir métricas nas arestas, como o número de funções ou tipos utilizados de um pacote dependente, para identificar acoplamentos fortes.
\end{itemize}

\bibliographystyle{sbc}
\bibliography{sbc-template.bib}

\end{document}
